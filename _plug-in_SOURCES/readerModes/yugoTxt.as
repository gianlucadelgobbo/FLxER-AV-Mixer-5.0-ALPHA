class yugoTxt extends MovieClip {	var interval:Number;	var waitChar:String;	var charSpeed:Number;	var moveFix:Number;	var moveRange:Number;	var moveTrigger:Number;	/////////	var str:String;	var randomList:Array;	var textCount:Number;	var fixLength:Number;	var fixStr:String;	var a:Number;	/////	var cMin:Number;	var cMax:Number;	var listener:Array;	var c:Number;	/////	var randomTypo;	var end_textCount;	var end_charMotion;	var typoText;	var previous_instance;	//	var n:Number;	var myTime:Number;	var myTxt:Array;	var txtInt;	var lab	var trgt	function yugoTxt(t) {		trgt = t		interval = 2000;		//trgt = typoText;		//titArray = _global.titles;		waitChar = "-";		moveFix = 10;		moveRange = 15;		moveTrigger = 12;		charSpeed = 2;		///////		cMin = 33;		cMax = 96;		listener = [];	}	function startReader(txt, tt) {		trace("YYYYYYYYYYYY "+txt)		myTxt = txt.split(" ");		myTime = tt		n = 0;		myPlay();	}	function myPlay() {		clearInterval(this.txtInt);		clearInterval(c);		if (this.myTxt.length>0) {			waitChar = "-";			moveFix = 10;			moveRange = 15;			moveTrigger = 12;			charSpeed = 2;			setText(waitChar, charSpeed, moveFix, moveRange, moveTrigger);		}	}	function leggi(trgt) {		clearInterval(this.txtInt);		clearInterval(c);		if (this.myTxt.length>0) {			waitChar = "-";			moveFix = 10;			moveRange = 15;			moveTrigger = 12;			charSpeed = 2;			//this.txtInt = setInterval(this, "setText", interval, trgt, waitChar, charSpeed, moveFix, moveRange, moveTrigger);			setText(waitChar, charSpeed, moveFix, moveRange, moveTrigger);		}	}	function myStop(trgt) {		clearInterval(this.txtInt);	}	function myRewind(trgt) {		n = 0;	}	function setText(waitChar, charSpeed, moveFix, moveRange, moveTrigger) {		str = myTxt[n].toUpperCase();		if (str != undefined) {			randomList = [];			textCount = 0;			fixLength = 0;			fixStr = "";			for (a=0; a<=str.length-1; a++) {				if (str.charAt(a) != " ") {					randomList[a] = (moveFix+Math.round(Math.random()*moveRange))*(Math.round(Math.random())-0.500000)*2;				} else {					randomList[a] = 0;				}			}			this.txtInt = setInterval(this, "randomMotion", myTime/10);			//trgt.onEnterFrame = this.randomMotion;		}		n++;		if (n>=myTxt.length) {			n = 0;		}	}	function randomMotion() {		trgt.lab.text = fixStr;		//trgt.lettore(fixStr, fixStr, fixStr);		var tmp = fixStr;		//this.text = fixStr;		end_charMotion = true;		for (a=fixLength; a<=textCount; a++) {			if (randomList[a] != 0 && randomList[a] != undefined) {				end_charMotion = false;				if (Math.abs(randomList[a])<=moveTrigger) {					var charcode = Math.min(Math.max(str.charCodeAt(a)+randomList[a], cMin), cMax);					tmp = tmp+String.fromCharCode(charcode);							trgt.lab.text = tmp;		//trgt.lettore(tmp, tmp, fixStr);					//this.text = this.text+String.fromCharCode(charcode);				} else {					tmp = tmp+waitChar;							trgt.lab.text = fixStr;		//trgt.lettore(tmp, tmp, fixStr);					//this.text = this.text+waitChar;				}				if (randomList[a]>0) {					randomList[a] = randomList[a]-1;				} else {					randomList[a] = randomList[a]+1;				}			} else {				if (fixLength == a-1) {					fixLength = a;					fixStr = str.substring(0, fixLength);				}				tmp = tmp+str.charAt(a);				trgt.lab.text = tmp;				//trgt.lettore(tmp, tmp, fixStr);				//this.text = this.text+str.charAt(a);			}		}		if (textCount<=str.length) {			textCount = textCount+charSpeed;		} else {			end_textCount = true;		}		if (end_charMotion && end_textCount) {			stopAction(trgt);		}	}	function stopAction(trgt) {		clearInterval(this.txtInt);		c = setInterval(this, "leggi", myTime);		// delete trgt.onEnterFrame;		delete randomList;		delete textCount;		delete end_textCount;		delete end_charMotion;		delete fixStr;		delete fixLength;		delete str;	}}